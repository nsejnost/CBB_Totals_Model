"""
Feature engineering for the NCAAB totals model.

Key philosophy: overcome KenPom's shortcomings by capturing:
  1. Non-linear pace x efficiency interactions
  2. Recency-weighted trajectories (not just season averages)
  3. Matchup-specific tempo dynamics
  4. Game-context features (venue, conference, mismatch level)
  5. Scoring volatility & consistency
  6. Opponent-quality-adjusted metrics
  7. Home-court advantage & conference indicators
"""

import numpy as np
import pandas as pd

# ---------------------------------------------------------------------------
# Core feature definitions
# ---------------------------------------------------------------------------

# These are the rolling stat columns generated by data_loader.build_rolling_stats
_WINDOWS = [5, 10, 20]
_EMA = 10
_STATS = ["adjt", "adjo", "adjd", "pts", "opp_pts", "ppp", "opp_ppp",
          "tempo", "possessions"]

# Major conference identifiers (Torvik conference abbreviations)
_MAJOR_CONFERENCES = {"B12", "B10", "SEC", "ACC", "BE", "P12", "MWC", "A10", "WCC", "MVC"}


def _col(side: str, stat: str, suffix: str) -> str:
    """Column name helper: h_ or a_ prefix."""
    return f"{side}_{stat}_{suffix}"


def build_feature_matrix(merged: pd.DataFrame) -> tuple[pd.DataFrame, list[str]]:
    """
    Build the full feature matrix from the merged Vegas+Torvik dataset.

    Returns (features_df, feature_column_names).
    """
    df = merged.copy()
    feat_cols: list[str] = []

    # ------------------------------------------------------------------
    # 1. Raw rolling / EMA stats for both sides
    # ------------------------------------------------------------------
    for side in ["h", "a"]:
        for stat in _STATS:
            for suffix in [f"ema{_EMA}", "season"] + [f"roll{w}" for w in _WINDOWS] + ["std5"]:
                col = _col(side, stat, suffix)
                if col in df.columns:
                    feat_cols.append(col)

    # ------------------------------------------------------------------
    # 2. Opponent-quality-adjusted features
    # ------------------------------------------------------------------
    for side in ["h", "a"]:
        for c in ["opp_qual_ema", "opp_rk_ema", "games_played"]:
            full = f"{side}_{c}"
            if full in df.columns and df[full].notna().mean() > 0.5:
                feat_cols.append(full)

    # ------------------------------------------------------------------
    # 3. KenPom-style baseline (for comparison / stacking)
    # ------------------------------------------------------------------
    # Traditional: predicted_total ~ (AdjO_A + AdjO_B) / 2 adjusted by pace
    for suffix in [f"ema{_EMA}", "season"]:
        ho = _col("h", "adjo", suffix)
        hd = _col("h", "adjd", suffix)
        ao = _col("a", "adjo", suffix)
        ad = _col("a", "adjd", suffix)
        ht = _col("h", "adjt", suffix)
        at = _col("a", "adjt", suffix)

        if all(c in df.columns for c in [ho, hd, ao, ad, ht, at]):
            # KenPom-style linear estimate
            avg_tempo = (df[ht] + df[at]) / 2.0
            # Home team expected points = possessions * (home_off_eff * away_def_eff / avg)
            # Simplified: tempo * (home_adjo + away_adjo) / 100
            kp_total = avg_tempo * (df[ho] + df[ao]) / 100.0
            tag = f"kenpom_total_{suffix}"
            df[tag] = kp_total
            feat_cols.append(tag)

            # KenPom residual vs Vegas
            kp_resid = f"kenpom_vs_vegas_{suffix}"
            df[kp_resid] = kp_total - df["vegas_total"]
            feat_cols.append(kp_resid)

    # ------------------------------------------------------------------
    # 4. Pace-interaction features (non-linear, matchup-specific)
    #    This is the main KenPom improvement.
    # ------------------------------------------------------------------
    for suffix in [f"ema{_EMA}", f"roll5"]:
        ht = _col("h", "adjt", suffix)
        at = _col("a", "adjt", suffix)
        htempo = _col("h", "tempo", suffix)
        atempo = _col("a", "tempo", suffix)

        if all(c in df.columns for c in [ht, at]):
            # Tempo differential – measures whether the game will be
            # pushed faster/slower than average
            df[f"tempo_diff_{suffix}"] = df[ht] - df[at]
            feat_cols.append(f"tempo_diff_{suffix}")

            # Tempo product (interaction) – high when both teams are fast
            df[f"tempo_product_{suffix}"] = df[ht] * df[at]
            feat_cols.append(f"tempo_product_{suffix}")

            # Min-tempo (the slower team often controls pace)
            df[f"tempo_min_{suffix}"] = np.minimum(df[ht], df[at])
            feat_cols.append(f"tempo_min_{suffix}")

            # Max-tempo
            df[f"tempo_max_{suffix}"] = np.maximum(df[ht], df[at])
            feat_cols.append(f"tempo_max_{suffix}")

        if all(c in df.columns for c in [htempo, atempo]):
            # Actual game tempo interactions
            df[f"game_tempo_avg_{suffix}"] = (df[htempo] + df[atempo]) / 2
            feat_cols.append(f"game_tempo_avg_{suffix}")

    # ------------------------------------------------------------------
    # 5. Efficiency interactions (non-linear)
    # ------------------------------------------------------------------
    for suffix in [f"ema{_EMA}", "season"]:
        ho = _col("h", "adjo", suffix)
        hd = _col("h", "adjd", suffix)
        ao = _col("a", "adjo", suffix)
        ad = _col("a", "adjd", suffix)

        if all(c in df.columns for c in [ho, hd, ao, ad]):
            # Efficiency gap: how good is each offense vs opposing defense
            df[f"h_off_vs_a_def_{suffix}"] = df[ho] - df[ad]
            df[f"a_off_vs_h_def_{suffix}"] = df[ao] - df[hd]
            feat_cols.extend([
                f"h_off_vs_a_def_{suffix}",
                f"a_off_vs_h_def_{suffix}",
            ])

            # Combined offensive firepower
            df[f"combined_off_{suffix}"] = df[ho] + df[ao]
            feat_cols.append(f"combined_off_{suffix}")

            # Combined defensive weakness (higher = weaker defenses)
            df[f"combined_def_{suffix}"] = df[hd] + df[ad]
            feat_cols.append(f"combined_def_{suffix}")

            # Net efficiency product
            df[f"eff_product_{suffix}"] = (df[ho] - df[hd]) * (df[ao] - df[ad])
            feat_cols.append(f"eff_product_{suffix}")

    # ------------------------------------------------------------------
    # 6. Spread / mismatch features
    # ------------------------------------------------------------------
    df["abs_spread"] = df["closing_spread_home_point"].abs()
    df["spread_sq"] = df["abs_spread"] ** 2
    feat_cols.extend(["abs_spread", "spread_sq"])

    # Vegas implied team totals
    df["implied_home_total"] = (
        df["vegas_total"] / 2 - df["closing_spread_home_point"] / 2
    )
    df["implied_away_total"] = (
        df["vegas_total"] / 2 + df["closing_spread_home_point"] / 2
    )
    feat_cols.extend(["implied_home_total", "implied_away_total"])

    # Vegas total itself (the model learns deviations from market)
    feat_cols.append("vegas_total")

    # ------------------------------------------------------------------
    # 7. Scoring volatility features
    # ------------------------------------------------------------------
    for side in ["h", "a"]:
        for stat in ["pts", "opp_pts", "tempo"]:
            std_col = f"{side}_{stat}_std5"
            if std_col in df.columns:
                feat_cols.append(std_col)

    # Combined volatility
    hps = "h_pts_std5"
    aps = "a_pts_std5"
    if hps in df.columns and aps in df.columns:
        df["combined_pts_vol"] = df[hps] + df[aps]
        feat_cols.append("combined_pts_vol")

    # ------------------------------------------------------------------
    # 8. Recency momentum features
    # ------------------------------------------------------------------
    for side in ["h", "a"]:
        ema_col = f"{side}_pts_ema{_EMA}"
        season_col = f"{side}_pts_season"
        if ema_col in df.columns and season_col in df.columns:
            df[f"{side}_pts_momentum"] = df[ema_col] - df[season_col]
            feat_cols.append(f"{side}_pts_momentum")

        ema_t = f"{side}_adjt_ema{_EMA}"
        season_t = f"{side}_adjt_season"
        if ema_t in df.columns and season_t in df.columns:
            df[f"{side}_tempo_trend"] = df[ema_t] - df[season_t]
            feat_cols.append(f"{side}_tempo_trend")

    # ------------------------------------------------------------------
    # 9. Calendar & venue features
    # ------------------------------------------------------------------
    df["month"] = df["game_date"].dt.month
    game_dates = df["game_date"].dt.tz_localize(None) if df["game_date"].dt.tz else df["game_date"]
    df["day_of_season"] = (
        game_dates - game_dates.dt.to_period("Y").dt.start_time
    ).dt.days
    feat_cols.extend(["month", "day_of_season"])

    # ------------------------------------------------------------------
    # 10. Home-court advantage & conference features
    # ------------------------------------------------------------------
    # Venue: 1=home, 0=neutral/away (Torvik uses "H","A","N")
    for side, vcol in [("h", "h_venue"), ("a", "a_venue")]:
        if vcol in df.columns:
            df[f"{side}_is_home"] = (df[vcol].astype(str).str.strip().str.upper() == "H").astype(int)
            feat_cols.append(f"{side}_is_home")

    # Conference indicators
    h_conf_col = "h_conf"
    a_conf_col = "a_conf"
    if h_conf_col in df.columns and a_conf_col in df.columns:
        h_conf = df[h_conf_col].astype(str).str.strip().str.upper()
        a_conf = df[a_conf_col].astype(str).str.strip().str.upper()

        # Conference game indicator
        df["is_conf_game"] = (h_conf == a_conf).astype(int)
        feat_cols.append("is_conf_game")

        # Major conference indicator for each team
        df["h_major_conf"] = h_conf.isin(_MAJOR_CONFERENCES).astype(int)
        df["a_major_conf"] = a_conf.isin(_MAJOR_CONFERENCES).astype(int)
        feat_cols.extend(["h_major_conf", "a_major_conf"])

        # Both major conferences (power matchup)
        df["both_major"] = (df["h_major_conf"] & df["a_major_conf"]).astype(int)
        feat_cols.append("both_major")

    # ------------------------------------------------------------------
    # Cleanup: only keep columns that exist and have data
    # ------------------------------------------------------------------
    feat_cols = list(dict.fromkeys(feat_cols))  # deduplicate, preserve order
    feat_cols = [c for c in feat_cols if c in df.columns]

    return df, feat_cols
